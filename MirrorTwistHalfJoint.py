# -*- coding: utf-8 -*-
"""Mirror Twist and Half rotation joints created by ARigTool utilities.

This script mirrors twist chains and half rotation joints generated by
``CreateTwistChain`` and ``CreateHalfRotJoint``. Select the source joint
on one side (_L or _R naming) and the script will attempt to reproduce
its setup on the opposite side.
"""
import math
import maya.cmds as cmds

TWIST_LAYER = "twist_jnt"
HALF_LAYER = "halfrot_jnt"
TWIST_NODE_TYPES = {
    "plusMinusAverage",
    "multDoubleLinear",
    "addDoubleLinear",
    "setRange",
    "condition",
}
MIRROR_NEGATE_ATTRS = {"translateX"}


def _mirror_name(name):
    if "_L" in name:
        return name.replace("_L", "_R", 1)
    if "_R" in name:
        return name.replace("_R", "_L", 1)
    return None


def _uniquify(name):
    if not cmds.objExists(name):
        return name
    base = name
    idx = 1
    while True:
        candidate = f"{base}{idx:02d}"
        if not cmds.objExists(candidate):
            return candidate
        idx += 1


def _ensure_display_layer(name):
    if cmds.objExists(name):
        if cmds.nodeType(name) == "displayLayer":
            return name
        cmds.error(u"'{0}' は displayLayer ではありません。".format(name))
    return cmds.createDisplayLayer(name=name, empty=True, nr=True)


def _list_twist_children(joint):
    children = cmds.listRelatives(joint, c=True, type="joint") or []
    return [c for c in children if cmds.attributeQuery("twistWeight", node=c, exists=True)]


def _find_twist_reference(twist_joint, start):
    pma_nodes = cmds.listConnections(twist_joint + ".rotateX", s=True, d=False) or []
    for node in pma_nodes:
        if cmds.nodeType(node) != "plusMinusAverage":
            continue
        md_nodes = cmds.listConnections(node + ".input1D[1]", s=True, d=False) or []
        for md in md_nodes:
            if cmds.nodeType(md) != "multDoubleLinear":
                continue
            pma_sub_nodes = cmds.listConnections(md + ".input1", s=True, d=False) or []
            for pma_sub in pma_sub_nodes:
                if cmds.nodeType(pma_sub) != "plusMinusAverage":
                    continue
                inputs = cmds.listConnections(pma_sub + ".input1D[*]", s=True, d=False, p=True) or []
                for plug in inputs:
                    target = plug.split(".")[0]
                    if target == start:
                        continue
                    if cmds.nodeType(target) == "joint":
                        return target
    return None


def _collect_twist_data(start):
    twist_joints = _list_twist_children(start)
    if not twist_joints:
        return None

    try:
        twist_joints.sort(key=lambda x: cmds.getAttr(x + ".twistWeight"))
    except Exception:
        twist_joints.sort()

    ref = _find_twist_reference(twist_joints[0], start)
    weights = []
    scales = []
    for j in twist_joints:
        try:
            weights.append(cmds.getAttr(j + ".twistWeight"))
        except Exception:
            weights.append(0.0)
        if cmds.attributeQuery("twistScaleMax", node=j, exists=True):
            try:
                scales.append(cmds.getAttr(j + ".twistScaleMax"))
            except Exception:
                scales.append(1.0)
        else:
            scales.append(1.0)
    return {
        "start": start,
        "reference": ref,
        "weights": weights,
        "scales": scales,
        "count": len(twist_joints),
    }


def _cleanup_twist(mirror_start):
    twist_joints = _list_twist_children(mirror_start)
    if not twist_joints:
        return

    nodes_to_delete = set()
    to_visit = list(twist_joints)
    while to_visit:
        node = to_visit.pop()
        for attr in (".rotateX", ".scaleY", ".scaleZ"):
            plugs = cmds.listConnections(node + attr, s=True, d=False, p=True) or []
            for plug in plugs:
                src_node = plug.split(".")[0]
                if src_node == mirror_start:
                    continue
                if cmds.nodeType(src_node) in TWIST_NODE_TYPES and src_node not in nodes_to_delete:
                    nodes_to_delete.add(src_node)
                    upstream = cmds.listConnections(src_node, s=True, d=False) or []
                    for up in upstream:
                        if cmds.nodeType(up) in TWIST_NODE_TYPES and up not in nodes_to_delete:
                            to_visit.append(up)
    if nodes_to_delete:
        cmds.delete(list(nodes_to_delete))
    cmds.delete(twist_joints)


def _build_twist_chain(data, mirror_start):
    ref = data.get("reference")
    if not ref:
        cmds.warning(u"{0} のTwist参照ジョイントが見つかりません。".format(data["start"]))
        return

    mirror_ref = _mirror_name(ref)
    if not mirror_ref or not cmds.objExists(mirror_ref):
        cmds.warning(u"{0} のミラー参照ジョイント {1} が存在しません。".format(ref, mirror_ref or "?"))
        return

    if not cmds.objExists(mirror_start):
        cmds.warning(u"ミラー先ジョイント {0} が存在しません。".format(mirror_start))
        return

    _cleanup_twist(mirror_start)

    start_pos = cmds.xform(mirror_start, q=True, ws=True, t=True)
    ref_pos = cmds.xform(mirror_ref, q=True, ws=True, t=True)
    length = math.sqrt(sum((ref_pos[i] - start_pos[i]) ** 2 for i in range(3)))
    if length < 1e-5:
        cmds.warning(u"{0} と {1} の距離がゼロのためTwistを作成できません。".format(mirror_start, mirror_ref))
        return

    start_short = mirror_start.split("|")[-1]

    pma_sub = cmds.createNode("plusMinusAverage", n=_uniquify(f"{start_short}_twistDelta_PMA"))
    cmds.setAttr(pma_sub + ".operation", 2)
    cmds.connectAttr(mirror_ref + ".rotateX", pma_sub + ".input1D[0]", f=True)
    cmds.connectAttr(mirror_start + ".rotateX", pma_sub + ".input1D[1]", f=True)

    abs_neg = cmds.createNode("multDoubleLinear", n=_uniquify(f"{start_short}_twistAbsNeg_MDL"))
    cmds.setAttr(abs_neg + ".input2", -1)
    cmds.connectAttr(pma_sub + ".output1D", abs_neg + ".input1", f=True)

    cond_abs = cmds.createNode("condition", n=_uniquify(f"{start_short}_twistAbs_COND"))
    cmds.setAttr(cond_abs + ".operation", 4)
    cmds.setAttr(cond_abs + ".secondTerm", 0)
    cmds.connectAttr(pma_sub + ".output1D", cond_abs + ".firstTerm", f=True)
    cmds.connectAttr(abs_neg + ".output", cond_abs + ".colorIfTrueR", f=True)
    cmds.connectAttr(pma_sub + ".output1D", cond_abs + ".colorIfFalseR", f=True)

    twist_range = cmds.createNode("setRange", n=_uniquify(f"{start_short}_twistAmount_SR"))
    cmds.setAttr(twist_range + ".minX", 0)
    cmds.setAttr(twist_range + ".maxX", 1)
    cmds.setAttr(twist_range + ".oldMinX", 0)
    cmds.setAttr(twist_range + ".oldMaxX", 90)
    cmds.connectAttr(cond_abs + ".outColorR", twist_range + ".valueX", f=True)

    try:
        base_radius = cmds.getAttr(mirror_start + ".radius")
    except Exception:
        base_radius = 1.0

    created = []
    for idx, weight in enumerate(data["weights"], start=1):
        scale_max = data["scales"][idx - 1]
        j_name = _uniquify(f"{start_short}_twist{idx:02d}")
        j = cmds.duplicate(mirror_start, po=True, n=j_name)[0]
        try:
            cmds.parent(j, mirror_start)
        except Exception:
            pass

        cmds.setAttr(j + ".translate", 0, 0, 0, type="double3")
        cmds.setAttr(j + ".rotate", 0, 0, 0, type="double3")
        cmds.setAttr(j + ".translateX", length * weight)

        for ax in ("Y", "Z"):
            try:
                cmds.setAttr(j + ".translate" + ax, 0)
            except Exception:
                pass

        for ax in ("X", "Y", "Z"):
            try:
                cmds.setAttr(j + ".rotate" + ax, l=False, k=True, cb=True)
            except Exception:
                pass

        if cmds.attributeQuery("radius", node=j, exists=True):
            try:
                cmds.setAttr(j + ".radius", max(0.01, base_radius * 2.0))
            except Exception:
                pass

        if cmds.objExists(j + ".segmentScaleCompensate"):
            try:
                cmds.setAttr(j + ".segmentScaleCompensate", 0)
            except Exception:
                pass

        md = cmds.createNode("multDoubleLinear", n=_uniquify(f"{start_short}_twist{idx:02d}_MD"))
        cmds.connectAttr(pma_sub + ".output1D", md + ".input1", f=True)

        pma_add = cmds.createNode("plusMinusAverage", n=_uniquify(f"{start_short}_twist{idx:02d}_PMA"))
        cmds.setAttr(pma_add + ".operation", 1)
        cmds.connectAttr(mirror_start + ".rotateX", pma_add + ".input1D[0]", f=True)
        cmds.connectAttr(md + ".output", pma_add + ".input1D[1]", f=True)
        cmds.connectAttr(pma_add + ".output1D", j + ".rotateX", f=True)

        for ax in ("Y", "Z"):
            try:
                cmds.setAttr(j + ".rotate" + ax, l=True, k=False, cb=False)
            except Exception:
                pass

        if not cmds.attributeQuery("twistWeight", node=j, exists=True):
            cmds.addAttr(j, ln="twistWeight", at="double", min=0.0, dv=weight)
            cmds.setAttr(j + ".twistWeight", e=True, k=True)
        cmds.setAttr(j + ".twistWeight", weight)
        cmds.connectAttr(j + ".twistWeight", md + ".input2", f=True)

        if not cmds.attributeQuery("twistScaleMax", node=j, exists=True):
            cmds.addAttr(j, ln="twistScaleMax", at="double", min=0.0, dv=scale_max)
            cmds.setAttr(j + ".twistScaleMax", e=True, k=True)
        else:
            cmds.setAttr(j + ".twistScaleMax", scale_max)

        delta_add = cmds.createNode("addDoubleLinear", n=_uniquify(f"{start_short}_twist{idx:02d}_scaleDelta_ADL"))
        cmds.connectAttr(j + ".twistScaleMax", delta_add + ".input1", f=True)
        cmds.setAttr(delta_add + ".input2", -1)

        scale_md = cmds.createNode("multDoubleLinear", n=_uniquify(f"{start_short}_twist{idx:02d}_scale_MD"))
        cmds.connectAttr(twist_range + ".outValueX", scale_md + ".input1", f=True)
        cmds.connectAttr(delta_add + ".output", scale_md + ".input2", f=True)

        scale_add = cmds.createNode("addDoubleLinear", n=_uniquify(f"{start_short}_twist{idx:02d}_scale_ADL"))
        cmds.connectAttr(scale_md + ".output", scale_add + ".input1", f=True)
        cmds.setAttr(scale_add + ".input2", 1)
        cmds.connectAttr(scale_add + ".output", j + ".scaleY", f=True)
        cmds.connectAttr(scale_add + ".output", j + ".scaleZ", f=True)

        created.append(j)

    layer = _ensure_display_layer(TWIST_LAYER)
    if created:
        try:
            cmds.editDisplayLayerMembers(layer, created, nr=True)
        except Exception:
            pass
        cmds.select(created, add=True)
        cmds.inViewMessage(amg=u"<hl>Twist ミラー作成</hl><br>%s" % "\n".join(created), pos="topCenter", fade=True)


def _collect_half_data(start):
    children = cmds.listRelatives(start, c=True, type="joint") or []
    half_joints = [c for c in children if c.endswith("_Half")]
    if not half_joints:
        return None

    data = []
    for half in half_joints:
        infs = cmds.listRelatives(half, c=True, type="joint") or []
        inf_infos = []
        for inf in infs:
            pos = cmds.xform(inf, q=True, ws=True, t=True)
            radius = 1.0
            try:
                radius = cmds.getAttr(inf + ".radius")
            except Exception:
                pass
            anim_curves = cmds.listConnections(inf, s=True, d=False, type="animCurve") or []
            driven_attrs = []
            for curve in anim_curves:
                outputs = cmds.listConnections(curve + ".output", s=False, d=True, p=True) or []
                for plug in outputs:
                    if plug.startswith(inf + "."):
                        driven_attrs.append(plug.split(".")[1])
            inf_infos.append({
                "name": inf,
                "position": pos,
                "radius": radius,
                "driven": list(set(driven_attrs)),
            })
        ro = cmds.getAttr(half + ".rotateOrder")
        try:
            half_radius = cmds.getAttr(half + ".radius")
        except Exception:
            half_radius = 1.0
        data.append({
            "name": half,
            "rotateOrder": ro,
            "radius": half_radius,
            "infs": inf_infos,
        })
    return data


def _cleanup_half(mirror_start):
    children = cmds.listRelatives(mirror_start, c=True, type="joint") or []
    half_joints = [c for c in children if c.endswith("_Half")]
    if half_joints:
        cmds.delete(half_joints)


def _copy_driven_keys(src, dst, attrs):
    for attr in attrs:
        try:
            cmds.copyKey(src, attribute=attr)
            cmds.pasteKey(dst, attribute=attr, option="replace")
            if attr in MIRROR_NEGATE_ATTRS:
                cmds.scaleKey(dst, attribute=attr, valueScale=-1)
        except Exception:
            pass


def _build_half_chain(data, mirror_start):
    if not data:
        return

    if not cmds.objExists(mirror_start):
        return

    _cleanup_half(mirror_start)

    start_short = mirror_start.split("|")[-1]

    layer = _ensure_display_layer(HALF_LAYER)

    for info in data:
        mirror_name = _mirror_name(info["name"])
        if not mirror_name:
            continue
        mirror_name = _uniquify(mirror_name)
        half = cmds.duplicate(mirror_start, po=True, n=mirror_name)[0]
        cmds.matchTransform(half, mirror_start, pos=True, rot=True, scl=False)
        cmds.setAttr(half + ".rotateOrder", info["rotateOrder"])
        try:
            cmds.setAttr(half + ".radius", max(0.01, info["radius"]))
        except Exception:
            pass

        md_name = _uniquify("md_%s_half" % start_short)
        md = cmds.createNode("multiplyDivide", n=md_name)
        cmds.setAttr(md + ".operation", 1)
        cmds.setAttr(md + ".input2X", 0.5)
        cmds.setAttr(md + ".input2Y", 0.5)
        cmds.setAttr(md + ".input2Z", 0.5)

        for ax in ("X", "Y", "Z"):
            dst_plug = f"{half}.rotate{ax}"
            cons = cmds.listConnections(dst_plug, s=True, d=False, p=True) or []
            for c in cons:
                try:
                    cmds.disconnectAttr(c, dst_plug)
                except Exception:
                    pass

        cmds.connectAttr(mirror_start + ".rotateX", md + ".input1X", f=True)
        cmds.connectAttr(mirror_start + ".rotateY", md + ".input1Y", f=True)
        cmds.connectAttr(mirror_start + ".rotateZ", md + ".input1Z", f=True)
        cmds.connectAttr(md + ".outputX", half + ".rotateX", f=True)
        cmds.connectAttr(md + ".outputY", half + ".rotateY", f=True)
        cmds.connectAttr(md + ".outputZ", half + ".rotateZ", f=True)

        created_infs = []
        for inf_info in info["infs"]:
            inf_name = _mirror_name(inf_info["name"]) or (mirror_name + "_INF")
            inf_name = _uniquify(inf_name)
            cmds.select(clear=True)
            inf = cmds.joint(n=inf_name)
            cmds.parent(inf, half)
            cmds.setAttr(inf + ".translate", 0, 0, 0, type="double3")
            cmds.setAttr(inf + ".rotate", 0, 0, 0, type="double3")
            cmds.setAttr(inf + ".jointOrient", 0, 0, 0, type="double3")
            try:
                cmds.setAttr(inf + ".radius", max(0.01, inf_info["radius"]))
            except Exception:
                pass

            pos = inf_info["position"]
            mirror_pos = [-pos[0], pos[1], pos[2]]
            cmds.xform(inf, ws=True, t=mirror_pos)

            _copy_driven_keys(inf_info["name"], inf, inf_info["driven"])
            created_infs.append(inf)

        try:
            cmds.editDisplayLayerMembers(layer, [half] + created_infs, nr=True)
        except Exception:
            pass

    if data:
        cmds.inViewMessage(amg=u"<hl>Half ミラー作成</hl>", pos="topCenter", fade=True)


def mirror_twist_and_half():
    selection = cmds.ls(sl=True, type="joint") or []
    if not selection:
        cmds.warning(u"ジョイントを選択してください。")
        return

    cmds.undoInfo(openChunk=True)
    try:
        for joint in selection:
            mirror_joint = _mirror_name(joint)
            if not mirror_joint or not cmds.objExists(mirror_joint):
                cmds.warning(u"{0} のミラー先ジョイントが見つかりません。".format(joint))
                continue

            twist_data = _collect_twist_data(joint)
            if twist_data:
                _build_twist_chain(twist_data, mirror_joint)

            half_data = _collect_half_data(joint)
            if half_data:
                _build_half_chain(half_data, mirror_joint)
    finally:
        cmds.undoInfo(closeChunk=True)


if __name__ == "__main__":
    mirror_twist_and_half()
