# -*- coding: utf-8 -*-
"""Mirror Twist, Half rotation, and Support joints created by ARigTool utilities.

This script mirrors twist chains, half rotation joints, and support joints
generated by ARigTool helpers. Select the source joint on one side (_L or
_R naming) and the script will attempt to reproduce its setup—including
driven keys—on the opposite side.
"""
import maya.cmds as cmds

from CreateHalfRotJoint import (
    build_half_chain_from_data,
    collect_half_joint_data,
)
from CreateTwistChain import (
    build_twist_chain_from_data,
    collect_twist_chain_data,
)

SUPPORT_LAYER = "support_jnt"
ANIM_CURVE_TYPES = (
    "animCurveUL",
    "animCurveUA",
    "animCurveUT",
    "animCurveUU",
)
def _should_negate_attr(attr):
    """Return True when mirrored driven keys should invert the value scale."""

    if not attr:
        return False
    attr_name = attr.split(".")[-1]
    return attr_name.endswith("Y")


def _mirror_attribute_plug(plug):
    if not plug or "." not in plug:
        return None

    node, attr = plug.rsplit(".", 1)
    mirror_node = _mirror_name(node)
    if not mirror_node and "|" in node:
        mirrored_path = _mirror_path(node)
        if mirrored_path != node:
            mirror_node = mirrored_path
    if not mirror_node:
        return None
    return f"{mirror_node}.{attr}"


def _strip_reverse_suffix(name):
    if name.endswith("_D"):
        return name[:-2]
    return name


def _mirror_name(name):
    base = _strip_reverse_suffix(name)
    mirrored = None
    if "_L" in base:
        mirrored = base.replace("_L", "_R", 1)
    elif "_R" in base:
        mirrored = base.replace("_R", "_L", 1)

    if not mirrored:
        return None

    if name.endswith("_D"):
        candidate = mirrored + "_D"
        if cmds.objExists(candidate):
            return candidate

    return mirrored


def _uniquify(name):
    if not cmds.objExists(name):
        return name
    base = name
    idx = 1
    while True:
        candidate = f"{base}{idx:02d}"
        if not cmds.objExists(candidate):
            return candidate
        idx += 1


def _ensure_display_layer(name):
    if cmds.objExists(name):
        if cmds.nodeType(name) == "displayLayer":
            return name
        cmds.error(u"'{0}' は displayLayer ではありません。".format(name))
    return cmds.createDisplayLayer(name=name, empty=True, nr=True)


def _mirror_path(path):
    parts = [part for part in path.split("|") if part]
    mirrored = []
    for part in parts:
        mirrored.append(_mirror_name(part) or part)
    if not parts:
        return path
    prefix = "|" if path.startswith("|") else ""
    return prefix + "|".join(mirrored)


def _mirror_position(position):
    if not position or len(position) != 3:
        return position
    return [-position[0], position[1], position[2]]


def _find_joint_by_short_name(base_joint, short_name):
    parent = cmds.listRelatives(base_joint, p=True, pa=True) or []
    search_candidates = []
    if parent:
        siblings = cmds.listRelatives(parent[0], c=True, type="joint", pa=True) or []
        search_candidates.extend(siblings)
    matches = cmds.ls(short_name, type="joint", long=True) or []
    search_candidates.extend(matches)

    seen = set()
    for candidate in search_candidates:
        if not candidate or candidate in seen:
            continue
        seen.add(candidate)
        if candidate.split("|")[-1] == short_name:
            return candidate
    return None


def _find_reverse_twist_root(start):
    short_name = start.split("|")[-1]
    base_short = _strip_reverse_suffix(short_name)
    if not base_short:
        return None

    target_short = f"{base_short}_twistRoot"
    parent = cmds.listRelatives(start, p=True, pa=True) or []
    if parent:
        siblings = cmds.listRelatives(parent[0], c=True, type="joint", pa=True) or []
    else:
        siblings = cmds.ls("|*", type="joint", long=True) or []

    start_long = cmds.ls(start, long=True) or [start]
    start_long = start_long[0]

    for sibling in siblings:
        if not sibling or sibling == start_long:
            continue
        short = sibling.split("|")[-1]
        if short == target_short:
            return sibling

    for sibling in siblings:
        if not sibling or sibling == start_long:
            continue
        if "twistroot" in sibling.split("|")[-1].lower():
            return sibling

    return _find_joint_by_short_name(start, target_short)




def _is_half_support_joint(joint):
    short_name = joint.split("|")[-1]
    lowered = short_name.lower()
    return "_sup" in lowered


def _list_connected_anim_curves(target, **kwargs):
    connections = cmds.listConnections(target, **kwargs) or []
    result = []
    for connection in connections:
        node = connection.split(".")[0] if isinstance(connection, str) else connection
        if cmds.nodeType(node) in ANIM_CURVE_TYPES:
            result.append(connection)
    return result


def _list_driven_attributes(node):
    anim_curves = _list_connected_anim_curves(node, s=True, d=False) or []
    attrs = []
    for curve in anim_curves:
        outputs = cmds.listConnections(curve + ".output", s=False, d=True, p=True) or []
        for plug in outputs:
            attrs.append(plug.split(".", 1)[1])
    return sorted(set(attrs))








def _copy_driven_keys(src, dst, attrs):
    if not attrs:
        return

    for attr in attrs:
        dst_attr = f"{dst}.{attr}"
        src_attr = f"{src}.{attr}"
        source_curves = _list_connected_anim_curves(src_attr, s=True, d=False)
        if not source_curves:
            continue
        driver_plugs = []
        for curve in source_curves:
            inputs = cmds.listConnections(curve, s=True, d=False, p=True, scn=True) or []
            for plug in inputs:
                if plug not in driver_plugs:
                    driver_plugs.append(plug)
        try:
            cmds.cutKey(dst, attribute=attr)
        except RuntimeError as exc:
            cmds.warning("{0}: cutKey failed ({1})".format(dst_attr, exc))

        duplicated_curves = []
        for curve in source_curves:
            try:
                duplicated = cmds.duplicate(curve, rc=True)[0]
            except RuntimeError:
                try:
                    duplicated = cmds.duplicate(curve)[0]
                except RuntimeError as exc:
                    cmds.warning("Failed to duplicate {0}: {1}".format(curve, exc))
                    continue

            duplicated_curves.append(duplicated)
            try:
                cmds.connectAttr(duplicated + ".output", dst_attr, f=True)
            except RuntimeError as exc:
                cmds.warning("Failed to connect {0} to {1}: {2}".format(duplicated, dst_attr, exc))
                try:
                    cmds.delete(duplicated)
                except RuntimeError:
                    pass
                duplicated_curves.pop()
                continue

            existing_inputs = cmds.listConnections(duplicated + ".input", s=True, d=False, p=True) or []
            for plug in existing_inputs:
                mirrored_attr = _mirror_attribute_plug(plug)
                if not mirrored_attr or mirrored_attr == plug:
                    continue
                if not cmds.objExists(mirrored_attr.split(".")[0]):
                    continue
                if not cmds.objExists(mirrored_attr):
                    continue
                try:
                    cmds.connectAttr(mirrored_attr, duplicated + ".input", f=True)
                except RuntimeError as exc:
                    cmds.warning("Failed to connect {0} to {1}: {2}".format(mirrored_attr, duplicated + ".input", exc))
                    continue
                try:
                    cmds.disconnectAttr(plug, duplicated + ".input")
                except RuntimeError:
                    pass

            final_inputs = cmds.listConnections(duplicated + ".input", s=True, d=False, p=True) or []
            if final_inputs:
                continue

            for driver_plug in driver_plugs:
                mirrored_driver = _mirror_attribute_plug(driver_plug)
                if not mirrored_driver:
                    continue
                if not cmds.objExists(mirrored_driver.split(".")[0]):
                    continue
                if not cmds.objExists(mirrored_driver):
                    continue
                try:
                    cmds.connectAttr(mirrored_driver, duplicated + ".input", f=True)
                    break
                except RuntimeError as exc:
                    cmds.warning("Failed to connect {0} to {1}: {2}".format(mirrored_driver, duplicated + ".input", exc))
                    continue

        if duplicated_curves and _should_negate_attr(attr):
            try:
                cmds.scaleKey(dst, attribute=attr, valueScale=-1)
            except RuntimeError as exc:
                cmds.warning("{0}: scaleKey failed ({1})".format(dst_attr, exc))


def _collect_support_data(start, mirror_start):
    start_short = start.split("|")[-1]
    mirror_short = mirror_start.split("|")[-1] if mirror_start else None
    if start_short.endswith("_L") or start_short.endswith("_R"):
        base_name = start_short[:-2]
    else:
        base_name = start_short
    joints = cmds.ls(type="joint", l=True) or []
    supports = []
    for joint in joints:
        short = joint.split("|")[-1]
        if not (short.startswith(start_short) or short.startswith(base_name)):
            continue
        if "_Sup" not in short:
            continue
        if "_L" in start_short and "_L" not in short:
            continue
        if "_R" in start_short and "_R" not in short:
            continue
        if "_L" in start_short and "_R" in short:
            continue
        if "_R" in start_short and "_L" in short:
            continue
        parent = cmds.listRelatives(joint, p=True, f=True)
        radius = 1.0
        try:
            radius = cmds.getAttr(joint + ".radius")
        except Exception:
            radius = 1.0
        supports.append({
            "name": joint,
            "short": short,
            "position": cmds.xform(joint, q=True, ws=True, t=True),
            "radius": radius,
            "parent": parent[0] if parent else None,
            "driven": _list_driven_attributes(joint),
            "base_prefix": base_name,
            "mirror_prefix": mirror_short,
        })
    return supports or None


def _cleanup_support(support_infos):
    if not support_infos:
        return
    for info in support_infos:
        mirror_name = _support_mirror_name(info)
        if not mirror_name:
            continue
        existing = cmds.ls(mirror_name, l=True) or []
        for node in existing:
            try:
                cmds.delete(node)
            except Exception:
                pass


def _build_support_joints(data):
    if not data:
        return

    layer = _ensure_display_layer(SUPPORT_LAYER)
    created = []
    for info in data:
        mirror_name = _support_mirror_name(info)
        if not mirror_name:
            continue
        new_name = _uniquify(mirror_name)
        try:
            duplicated = cmds.duplicate(info["name"], po=True)[0]
        except Exception:
            continue
        try:
            duplicated = cmds.rename(duplicated, new_name)
        except Exception:
            duplicated = cmds.rename(duplicated, _uniquify(new_name))

        cmds.parent(duplicated, w=True)
        parent = info.get("parent")
        target_parent = None
        if parent:
            mirror_parent = _mirror_path(parent)
            if cmds.objExists(mirror_parent):
                target_parent = mirror_parent
            elif cmds.objExists(parent):
                target_parent = parent
        if target_parent:
            try:
                cmds.parent(duplicated, target_parent)
            except Exception:
                pass
        try:
            pos = info.get("position")
            if pos and len(pos) == 3:
                mirror_pos = [-pos[0], pos[1], pos[2]]
                cmds.xform(duplicated, ws=True, t=mirror_pos)
        except Exception:
            pass
        try:
            cmds.setAttr(duplicated + ".radius", max(0.01, info["radius"]))
        except Exception:
            pass

        _copy_driven_keys(info["name"], duplicated, info["driven"])

        try:
            cmds.editDisplayLayerMembers(layer, duplicated, nr=True)
        except Exception:
            pass
        created.append(duplicated)

    if created:
        cmds.inViewMessage(amg=u"<hl>Support ミラー作成</hl>", pos="topCenter", fade=True)


def _support_mirror_name(info):
    mirror_name = _mirror_name(info["short"])
    if mirror_name:
        return mirror_name
    base_prefix = info.get("base_prefix")
    mirror_prefix = info.get("mirror_prefix")
    if base_prefix and mirror_prefix and info["short"].startswith(base_prefix):
        return mirror_prefix + info["short"][len(base_prefix) :]
    return None


def mirror_twist_and_half():
    selection = cmds.ls(sl=True, type="joint") or []
    if not selection:
        cmds.warning("Select a joint.")
        return

    cmds.undoInfo(openChunk=True)
    try:
        for joint in selection:
            mirror_joint = _mirror_name(joint)
            mirror_exists = mirror_joint and cmds.objExists(mirror_joint)

            if mirror_joint and not mirror_exists:
                cmds.warning("Mirror joint for {0} was not found; skipping twist/half mirroring.".format(joint))

            if mirror_exists:
                twist_data = collect_twist_chain_data(joint)
                if twist_data:
                    build_twist_chain_from_data(
                        mirror_joint,
                        twist_data,
                        copy_driven_callback=_copy_driven_keys,
                        select_result=True,
                        show_message=True,
                    )

                half_data = collect_half_joint_data(joint)
                if half_data:
                    build_half_chain_from_data(
                        mirror_joint,
                        half_data,
                        name_mapper=_mirror_name,
                        position_mapper=_mirror_position,
                        copy_driven_callback=_copy_driven_keys,
                        select_result=False,
                        show_message=True,
                    )
            elif not mirror_joint:
                cmds.warning("{0} does not contain '_L' or '_R'; skipping twist/half mirroring.".format(joint))

            support_data = _collect_support_data(joint, mirror_joint if mirror_exists else None)
            if support_data:
                _cleanup_support(support_data)
                _build_support_joints(support_data)
    finally:
        cmds.undoInfo(closeChunk=True)


if __name__ == "__main__":
    mirror_twist_and_half()
