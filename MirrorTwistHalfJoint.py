# -*- coding: utf-8 -*-
"""Mirror Twist and Half rotation joints created by ARigTool utilities.

This script mirrors twist chains and half rotation joints generated by
``CreateTwistChain`` and ``CreateHalfRotJoint``. Select the source joint
on one side (_L or _R naming) and the script will attempt to reproduce
its setup on the opposite side.
"""
import maya.cmds as cmds

from CreateHalfRotJoint import create_half_rotation_joint
from CreateTwistChain import create_twist_chain

TWIST_LAYER = "twist_jnt"
HALF_LAYER = "halfrot_jnt"
TWIST_NODE_TYPES = {
    "plusMinusAverage",
    "multDoubleLinear",
    "addDoubleLinear",
    "setRange",
    "condition",
}
MIRROR_NEGATE_ATTRS = {"translateX"}


def _mirror_name(name):
    if "_L" in name:
        return name.replace("_L", "_R", 1)
    if "_R" in name:
        return name.replace("_R", "_L", 1)
    return None


def _uniquify(name):
    if not cmds.objExists(name):
        return name
    base = name
    idx = 1
    while True:
        candidate = f"{base}{idx:02d}"
        if not cmds.objExists(candidate):
            return candidate
        idx += 1


def _ensure_display_layer(name):
    if cmds.objExists(name):
        if cmds.nodeType(name) == "displayLayer":
            return name
        cmds.error(u"'{0}' は displayLayer ではありません。".format(name))
    return cmds.createDisplayLayer(name=name, empty=True, nr=True)


def _list_twist_children(joint):
    result = []
    children = cmds.listRelatives(joint, c=True, type="joint") or []
    for child in children:
        if cmds.attributeQuery("twistWeight", node=child, exists=True):
            result.append(child)
    return result


def _find_twist_reference(twist_joint, start):
    pma_nodes = cmds.listConnections(twist_joint + ".rotateX", s=True, d=False) or []
    for node in pma_nodes:
        if cmds.nodeType(node) != "plusMinusAverage":
            continue
        md_nodes = cmds.listConnections(node + ".input1D[1]", s=True, d=False) or []
        for md in md_nodes:
            if cmds.nodeType(md) != "multDoubleLinear":
                continue
            pma_sub_nodes = cmds.listConnections(md + ".input1", s=True, d=False) or []
            for pma_sub in pma_sub_nodes:
                if cmds.nodeType(pma_sub) != "plusMinusAverage":
                    continue
                inputs = cmds.listConnections(pma_sub + ".input1D[*]", s=True, d=False, p=True) or []
                for plug in inputs:
                    target = plug.split(".")[0]
                    if target == start:
                        continue
                    if cmds.nodeType(target) == "joint":
                        return target
    return None


def _collect_twist_data(start):
    twist_joints = _list_twist_children(start)
    if not twist_joints:
        return None

    try:
        twist_joints.sort(key=lambda x: cmds.getAttr(x + ".twistWeight"))
    except Exception:
        twist_joints.sort()

    ref = _find_twist_reference(twist_joints[0], start)
    weights = []
    scales = []
    for j in twist_joints:
        try:
            weights.append(cmds.getAttr(j + ".twistWeight"))
        except Exception:
            weights.append(0.0)
        if cmds.attributeQuery("twistScaleMax", node=j, exists=True):
            try:
                scales.append(cmds.getAttr(j + ".twistScaleMax"))
            except Exception:
                scales.append(1.0)
        else:
            scales.append(1.0)
    return {
        "start": start,
        "reference": ref,
        "weights": weights,
        "scales": scales,
        "count": len(twist_joints),
    }


def _cleanup_twist(mirror_start):
    twist_joints = _list_twist_children(mirror_start)
    if not twist_joints:
        return

    nodes_to_delete = set()
    to_visit = list(twist_joints)
    while to_visit:
        node = to_visit.pop()
        for attr in (".rotateX", ".scaleY", ".scaleZ"):
            plugs = cmds.listConnections(node + attr, s=True, d=False, p=True) or []
            for plug in plugs:
                src_node = plug.split(".")[0]
                if src_node == mirror_start:
                    continue
                if cmds.nodeType(src_node) in TWIST_NODE_TYPES and src_node not in nodes_to_delete:
                    nodes_to_delete.add(src_node)
                    upstream = cmds.listConnections(src_node, s=True, d=False) or []
                    for up in upstream:
                        if cmds.nodeType(up) in TWIST_NODE_TYPES and up not in nodes_to_delete:
                            to_visit.append(up)
    if nodes_to_delete:
        cmds.delete(list(nodes_to_delete))
    cmds.delete(twist_joints)


def _build_twist_chain(data, mirror_start):
    ref = data.get("reference")
    if not ref:
        cmds.warning(u"{0} のTwist参照ジョイントが見つかりません。".format(data["start"]))
        return

    mirror_ref = _mirror_name(ref)
    if not mirror_ref or not cmds.objExists(mirror_ref):
        cmds.warning(u"{0} のミラー参照ジョイント {1} が存在しません。".format(ref, mirror_ref or "?"))
        return

    if not cmds.objExists(mirror_start):
        cmds.warning(u"ミラー先ジョイント {0} が存在しません。".format(mirror_start))
        return

    if data.get("count", 0) <= 0:
        return

    _cleanup_twist(mirror_start)

    prev_sel = cmds.ls(sl=True)
    scale_at_90 = data["scales"][-1] if data["scales"] else 1.0
    try:
        cmds.select([mirror_start, mirror_ref], r=True)
        created = create_twist_chain(count=data["count"], scale_at_90=scale_at_90)
    finally:
        if prev_sel:
            cmds.select(prev_sel, r=True)
        else:
            cmds.select(clear=True)

    if not created:
        return

    created = created[: data["count"]]

    for idx, joint in enumerate(created):
        if idx >= len(data["weights"]):
            break
        weight = data["weights"][idx]
        scale_max = data["scales"][idx]
        if cmds.attributeQuery("twistWeight", node=joint, exists=True):
            try:
                cmds.setAttr(joint + ".twistWeight", weight)
            except Exception:
                pass
        if cmds.attributeQuery("twistScaleMax", node=joint, exists=True):
            try:
                cmds.setAttr(joint + ".twistScaleMax", scale_max)
            except Exception:
                pass

    layer = _ensure_display_layer(TWIST_LAYER)
    try:
        cmds.editDisplayLayerMembers(layer, created, nr=True)
    except Exception:
        pass
    cmds.select(created, add=True)
    cmds.inViewMessage(amg=u"<hl>Twist ミラー作成</hl><br>%s" % "\n".join(created), pos="topCenter", fade=True)


def _list_half_at_same_level(start):
    start_short = start.split("|")[-1]
    half_joints = []
    candidates = set(cmds.listRelatives(start, c=True, type="joint") or [])
    parent = cmds.listRelatives(start, p=True) or []
    if parent:
        siblings = cmds.listRelatives(parent[0], c=True, type="joint") or []
        candidates.update(siblings)

    for candidate in candidates:
        if candidate == start:
            continue
        short = candidate.split("|")[-1]
        if not short.startswith(f"{start_short}_Half"):
            continue
        half_joints.append(candidate)

    return half_joints


def _collect_half_data(start):
    half_joints = _list_half_at_same_level(start)
    if not half_joints:
        return None

    data = []
    for half in half_joints:
        infs = cmds.listRelatives(half, c=True, type="joint") or []
        inf_infos = []
        for inf in infs:
            pos = cmds.xform(inf, q=True, ws=True, t=True)
            radius = 1.0
            try:
                radius = cmds.getAttr(inf + ".radius")
            except Exception:
                pass
            anim_curves = cmds.listConnections(inf, s=True, d=False, type="animCurve") or []
            driven_attrs = []
            for curve in anim_curves:
                outputs = cmds.listConnections(curve + ".output", s=False, d=True, p=True) or []
                for plug in outputs:
                    if plug.startswith(inf + "."):
                        driven_attrs.append(plug.split(".")[1])
            inf_infos.append({
                "name": inf,
                "position": pos,
                "radius": radius,
                "driven": list(set(driven_attrs)),
            })
        ro = cmds.getAttr(half + ".rotateOrder")
        try:
            half_radius = cmds.getAttr(half + ".radius")
        except Exception:
            half_radius = 1.0
        data.append({
            "name": half,
            "rotateOrder": ro,
            "radius": half_radius,
            "infs": inf_infos,
        })
    return data


def _cleanup_half(mirror_start):
    half_joints = _list_half_at_same_level(mirror_start)
    if half_joints:
        cmds.delete(half_joints)


def _copy_driven_keys(src, dst, attrs):
    for attr in attrs:
        try:
            cmds.copyKey(src, attribute=attr)
            cmds.pasteKey(dst, attribute=attr, option="replace")
            if attr in MIRROR_NEGATE_ATTRS:
                cmds.scaleKey(dst, attribute=attr, valueScale=-1)
        except Exception:
            pass


def _build_half_chain(data, mirror_start):
    if not data:
        return

    if not cmds.objExists(mirror_start):
        return

    _cleanup_half(mirror_start)

    layer = _ensure_display_layer(HALF_LAYER)
    created_halves = []

    for info in data:
        mirror_name = _mirror_name(info["name"])
        if not mirror_name:
            continue

        prev_halfs = set(_list_half_at_same_level(mirror_start))
        prev_sel = cmds.ls(sl=True)
        try:
            cmds.select(mirror_start, r=True)
            create_half_rotation_joint()
        finally:
            if prev_sel:
                cmds.select(prev_sel, r=True)
            else:
                cmds.select(clear=True)

        new_halfs = list(set(_list_half_at_same_level(mirror_start)) - prev_halfs)
        if not new_halfs:
            cmds.warning(u"{0} のHalfジョイント作成に失敗しました。".format(mirror_name))
            continue

        new_halfs.sort()
        half = new_halfs[0]
        half = cmds.rename(half, _uniquify(mirror_name))

        try:
            cmds.setAttr(half + ".rotateOrder", info["rotateOrder"])
        except Exception:
            pass
        try:
            cmds.setAttr(half + ".radius", max(0.01, info["radius"]))
        except Exception:
            pass

        existing_children = cmds.listRelatives(half, c=True, type="joint") or []
        if existing_children:
            cmds.delete(existing_children)

        created_infs = []
        half_short = half.split("|")[-1]
        for inf_info in info["infs"]:
            inf_name = _mirror_name(inf_info["name"]) or (half_short + "_INF")
            inf_name = _uniquify(inf_name)
            cmds.select(clear=True)
            inf = cmds.joint(n=inf_name)
            cmds.parent(inf, half)
            cmds.setAttr(inf + ".translate", 0, 0, 0, type="double3")
            cmds.setAttr(inf + ".rotate", 0, 0, 0, type="double3")
            cmds.setAttr(inf + ".jointOrient", 0, 0, 0, type="double3")
            try:
                cmds.setAttr(inf + ".radius", max(0.01, inf_info["radius"]))
            except Exception:
                pass

            pos = inf_info["position"]
            mirror_pos = [-pos[0], pos[1], pos[2]]
            cmds.xform(inf, ws=True, t=mirror_pos)

            _copy_driven_keys(inf_info["name"], inf, inf_info["driven"])
            created_infs.append(inf)

        try:
            cmds.editDisplayLayerMembers(layer, [half] + created_infs, nr=True)
        except Exception:
            pass

        created_halves.append(half)

    if created_halves:
        cmds.inViewMessage(amg=u"<hl>Half ミラー作成</hl>", pos="topCenter", fade=True)


def mirror_twist_and_half():
    selection = cmds.ls(sl=True, type="joint") or []
    if not selection:
        cmds.warning(u"ジョイントを選択してください。")
        return

    cmds.undoInfo(openChunk=True)
    try:
        for joint in selection:
            mirror_joint = _mirror_name(joint)
            if not mirror_joint or not cmds.objExists(mirror_joint):
                cmds.warning(u"{0} のミラー先ジョイントが見つかりません。".format(joint))
                continue

            twist_data = _collect_twist_data(joint)
            if twist_data:
                _build_twist_chain(twist_data, mirror_joint)

            half_data = _collect_half_data(joint)
            if half_data:
                _build_half_chain(half_data, mirror_joint)
    finally:
        cmds.undoInfo(closeChunk=True)


if __name__ == "__main__":
    mirror_twist_and_half()
