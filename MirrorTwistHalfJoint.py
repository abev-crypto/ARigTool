# -*- coding: utf-8 -*-
"""Mirror Twist, Half rotation, and Support joints created by ARigTool utilities.

This script mirrors twist chains, half rotation joints, and support joints
generated by ARigTool helpers. Select the source joint on one side (_L or
_R naming) and the script will attempt to reproduce its setup—including
driven keys—on the opposite side.
"""
import maya.cmds as cmds

from CreateHalfRotJoint import create_half_rotation_joint
from CreateTwistChain import create_twist_chain

TWIST_LAYER = "twist_jnt"
HALF_LAYER = "halfrot_jnt"
SUPPORT_LAYER = "support_jnt"
TWIST_NODE_TYPES = {
    "plusMinusAverage",
    "multDoubleLinear",
    "addDoubleLinear",
    "setRange",
    "condition",
}
def _should_negate_attr(attr):
    """Return True when mirrored driven keys should invert the value scale."""

    if not attr:
        return False
    attr_name = attr.split(".")[-1]
    return attr_name.endswith("Y")


def _mirror_attribute_plug(plug):
    if not plug or "." not in plug:
        return None

    node, attr = plug.rsplit(".", 1)
    mirror_node = _mirror_name(node)
    if not mirror_node and "|" in node:
        mirrored_path = _mirror_path(node)
        if mirrored_path != node:
            mirror_node = mirrored_path
    if not mirror_node:
        return None
    return f"{mirror_node}.{attr}"


def _mirror_name(name):
    if "_L" in name:
        return name.replace("_L", "_R", 1)
    if "_R" in name:
        return name.replace("_R", "_L", 1)
    return None


def _uniquify(name):
    if not cmds.objExists(name):
        return name
    base = name
    idx = 1
    while True:
        candidate = f"{base}{idx:02d}"
        if not cmds.objExists(candidate):
            return candidate
        idx += 1


def _ensure_display_layer(name):
    if cmds.objExists(name):
        if cmds.nodeType(name) == "displayLayer":
            return name
        cmds.error(u"'{0}' は displayLayer ではありません。".format(name))
    return cmds.createDisplayLayer(name=name, empty=True, nr=True)


def _mirror_path(path):
    parts = [part for part in path.split("|") if part]
    mirrored = []
    for part in parts:
        mirrored.append(_mirror_name(part) or part)
    if not parts:
        return path
    prefix = "|" if path.startswith("|") else ""
    return prefix + "|".join(mirrored)


def _list_twist_children(joint):
    result = []
    children = cmds.listRelatives(joint, c=True, type="joint") or []
    for child in children:
        if cmds.attributeQuery("twistWeight", node=child, exists=True):
            result.append(child)
    return result


def _is_half_joint(joint):
    short_name = joint.split("|")[-1]
    lowered = short_name.lower()
    return (
        lowered.endswith("_half")
        or lowered.endswith("_half_inf")
        or "halfjoint" in lowered
    )


def _list_base_children(joint):
    children = cmds.listRelatives(joint, c=True, type="joint") or []
    bases = []
    for child in children:
        if _is_half_joint(child):
            continue
        if cmds.attributeQuery("twistWeight", node=child, exists=True):
            continue
        bases.append(child)
    return bases


def _list_driven_attributes(node):
    anim_curves = cmds.listConnections(node, s=True, d=False, type="animCurve") or []
    attrs = []
    for curve in anim_curves:
        outputs = cmds.listConnections(curve + ".output", s=False, d=True, p=True) or []
        for plug in outputs:
            if plug.startswith(node + "."):
                attrs.append(plug.split(".", 1)[1])
    return sorted(set(attrs))


def _collect_twist_data(start):
    twist_joints = _list_twist_children(start)
    if not twist_joints:
        return None

    try:
        twist_joints.sort(key=lambda x: cmds.getAttr(x + ".twistWeight"))
    except Exception:
        twist_joints.sort()

    weights = []
    scales = []
    driven = {}
    for j in twist_joints:
        try:
            weights.append(cmds.getAttr(j + ".twistWeight"))
        except Exception:
            weights.append(0.0)
        if cmds.attributeQuery("twistScaleMax", node=j, exists=True):
            try:
                scales.append(cmds.getAttr(j + ".twistScaleMax"))
            except Exception:
                scales.append(1.0)
        else:
            scales.append(1.0)
        driven[j] = _list_driven_attributes(j)
    return {
        "start": start,
        "weights": weights,
        "scales": scales,
        "count": len(twist_joints),
        "joints": twist_joints,
        "driven": driven,
    }


def _cleanup_twist(mirror_start):
    twist_joints = _list_twist_children(mirror_start)
    if not twist_joints:
        return

    nodes_to_delete = set()
    to_visit = list(twist_joints)
    while to_visit:
        node = to_visit.pop()
        for attr in (".rotateX", ".scaleY", ".scaleZ"):
            plugs = cmds.listConnections(node + attr, s=True, d=False, p=True) or []
            for plug in plugs:
                src_node = plug.split(".")[0]
                if src_node == mirror_start:
                    continue
                if cmds.nodeType(src_node) in TWIST_NODE_TYPES and src_node not in nodes_to_delete:
                    nodes_to_delete.add(src_node)
                    upstream = cmds.listConnections(src_node, s=True, d=False) or []
                    for up in upstream:
                        if cmds.nodeType(up) in TWIST_NODE_TYPES and up not in nodes_to_delete:
                            to_visit.append(up)
    if nodes_to_delete:
        cmds.delete(list(nodes_to_delete))
    cmds.delete(twist_joints)


def _build_twist_chain(data, mirror_start):
    if not cmds.objExists(mirror_start):
        cmds.warning(u"ミラー先ジョイント {0} が存在しません。".format(mirror_start))
        return

    if data.get("count", 0) <= 0:
        return

    base_candidates = _list_base_children(mirror_start)
    if not base_candidates:
        cmds.warning(u"{0} 直下にツイストの基礎となるジョイントが見つからないため、作成をスキップします。".format(mirror_start))
        return
    if len(base_candidates) > 1:
        cmds.warning(u"{0} 直下に複数の基礎ジョイントが存在するため、ツイストチェーンのミラー作成をスキップします。".format(mirror_start))
        return

    _cleanup_twist(mirror_start)

    prev_sel = cmds.ls(sl=True)
    scale_at_90 = data["scales"][-1] if data["scales"] else 1.0
    try:
        cmds.select([mirror_start], r=True)
        created = create_twist_chain(count=data["count"], scale_at_90=scale_at_90)
    finally:
        if prev_sel:
            cmds.select(prev_sel, r=True)
        else:
            cmds.select(clear=True)

    if not created:
        return

    created = created[: data["count"]]

    for idx, joint in enumerate(created):
        if idx >= len(data["weights"]):
            break
        weight = data["weights"][idx]
        scale_max = data["scales"][idx]
        src_joint = data["joints"][idx] if idx < len(data["joints"]) else None
        if cmds.attributeQuery("twistWeight", node=joint, exists=True):
            try:
                cmds.setAttr(joint + ".twistWeight", weight)
            except Exception:
                pass
        if cmds.attributeQuery("twistScaleMax", node=joint, exists=True):
            try:
                cmds.setAttr(joint + ".twistScaleMax", scale_max)
            except Exception:
                pass
        if src_joint:
            attrs = data["driven"].get(src_joint, [])
            _copy_driven_keys(src_joint, joint, attrs)

    layer = _ensure_display_layer(TWIST_LAYER)
    try:
        cmds.editDisplayLayerMembers(layer, created, nr=True)
    except Exception:
        pass
    cmds.select(created, add=True)
    cmds.inViewMessage(amg=u"<hl>Twist ミラー作成</hl><br>%s" % "\n".join(created), pos="topCenter", fade=True)


def _list_half_at_same_level(start):
    start_short = start.split("|")[-1]
    half_joints = []
    candidates = set(cmds.listRelatives(start, c=True, type="joint") or [])
    parent = cmds.listRelatives(start, p=True) or []
    if parent:
        siblings = cmds.listRelatives(parent[0], c=True, type="joint") or []
        candidates.update(siblings)

    for candidate in candidates:
        if candidate == start:
            continue
        short = candidate.split("|")[-1]
        if not short.startswith(f"{start_short}_Half"):
            continue
        half_joints.append(candidate)

    return half_joints


def _collect_half_data(start):
    half_joints = _list_half_at_same_level(start)
    if not half_joints:
        return None

    data = []
    for half in half_joints:
        infs = cmds.listRelatives(half, c=True, type="joint") or []
        inf_infos = []
        for inf in infs:
            pos = cmds.xform(inf, q=True, ws=True, t=True)
            radius = 1.0
            try:
                radius = cmds.getAttr(inf + ".radius")
            except Exception:
                pass
            driven_attrs = _list_driven_attributes(inf)
            inf_infos.append({
                "name": inf,
                "position": pos,
                "radius": radius,
                "driven": driven_attrs,
            })
        ro = cmds.getAttr(half + ".rotateOrder")
        try:
            half_radius = cmds.getAttr(half + ".radius")
        except Exception:
            half_radius = 1.0
        data.append({
            "name": half,
            "rotateOrder": ro,
            "radius": half_radius,
            "infs": inf_infos,
        })
    return data


def _cleanup_half(mirror_start):
    half_joints = _list_half_at_same_level(mirror_start)
    if half_joints:
        cmds.delete(half_joints)


def _copy_driven_keys(src, dst, attrs):
    if not attrs:
        return

    for attr in attrs:
        try:
            dst_attr = f"{dst}.{attr}"
            src_attr = f"{src}.{attr}"
            source_curves = cmds.listConnections(src_attr, s=True, d=False, type="animCurve") or []
            driver_plugs = []
            for curve in source_curves:
                inputs = cmds.listConnections(curve + ".input", s=True, d=False, p=True) or []
                for plug in inputs:
                    if plug not in driver_plugs:
                        driver_plugs.append(plug)
            existing = set(cmds.listConnections(dst_attr, s=True, d=False, type="animCurve") or [])
            try:
                cmds.cutKey(dst, attribute=attr)
            except Exception:
                pass
            cmds.copyKey(src, attribute=attr)
            cmds.pasteKey(dst, attribute=attr, option="replace")
            if _should_negate_attr(attr):
                cmds.scaleKey(dst, attribute=attr, valueScale=-1)

            new_curves = set(cmds.listConnections(dst_attr, s=True, d=False, type="animCurve") or []) - existing
            for curve in new_curves:
                inputs = cmds.listConnections(curve + ".input", s=True, d=False, p=True) or []
                for plug in inputs:
                    mirrored_attr = _mirror_attribute_plug(plug)
                    if not mirrored_attr or mirrored_attr == plug:
                        continue
                    if not cmds.objExists(mirrored_attr.split(".")[0]):
                        continue
                    if not cmds.objExists(mirrored_attr):
                        continue
                    try:
                        cmds.connectAttr(mirrored_attr, curve + ".input", f=True)
                    except Exception:
                        continue
                    try:
                        cmds.disconnectAttr(plug, curve + ".input")
                    except Exception:
                        pass

                final_inputs = cmds.listConnections(curve + ".input", s=True, d=False, p=True) or []
                if not final_inputs and driver_plugs:
                    for driver_plug in driver_plugs:
                        mirrored_driver = _mirror_attribute_plug(driver_plug)
                        if not mirrored_driver:
                            continue
                        if not cmds.objExists(mirrored_driver.split(".")[0]):
                            continue
                        if not cmds.objExists(mirrored_driver):
                            continue
                        try:
                            cmds.connectAttr(mirrored_driver, curve + ".input", f=True)
                        except Exception:
                            continue
                        break
        except Exception:
            pass


def _build_half_chain(data, mirror_start):
    if not data:
        return

    if not cmds.objExists(mirror_start):
        return

    _cleanup_half(mirror_start)

    layer = _ensure_display_layer(HALF_LAYER)
    created_halves = []

    for info in data:
        mirror_name = _mirror_name(info["name"])
        if not mirror_name:
            continue

        prev_halfs = set(_list_half_at_same_level(mirror_start))
        prev_sel = cmds.ls(sl=True)
        try:
            cmds.select(mirror_start, r=True)
            create_half_rotation_joint()
        finally:
            if prev_sel:
                cmds.select(prev_sel, r=True)
            else:
                cmds.select(clear=True)

        new_halfs = list(set(_list_half_at_same_level(mirror_start)) - prev_halfs)
        if not new_halfs:
            cmds.warning(u"{0} のHalfジョイント作成に失敗しました。".format(mirror_name))
            continue

        new_halfs.sort()
        half = new_halfs[0]
        half = cmds.rename(half, _uniquify(mirror_name))

        try:
            cmds.setAttr(half + ".rotateOrder", info["rotateOrder"])
        except Exception:
            pass
        try:
            cmds.setAttr(half + ".radius", max(0.01, info["radius"]))
        except Exception:
            pass

        existing_children = cmds.listRelatives(half, c=True, type="joint") or []
        if existing_children:
            cmds.delete(existing_children)

        created_infs = []
        half_short = half.split("|")[-1]
        for inf_info in info["infs"]:
            inf_name = _mirror_name(inf_info["name"]) or (half_short + "_INF")
            inf_name = _uniquify(inf_name)
            cmds.select(clear=True)
            inf = cmds.joint(n=inf_name)
            cmds.parent(inf, half)
            cmds.setAttr(inf + ".translate", 0, 0, 0, type="double3")
            cmds.setAttr(inf + ".rotate", 0, 0, 0, type="double3")
            cmds.setAttr(inf + ".jointOrient", 0, 0, 0, type="double3")
            try:
                cmds.setAttr(inf + ".radius", max(0.01, inf_info["radius"]))
            except Exception:
                pass

            pos = inf_info["position"]
            mirror_pos = [-pos[0], pos[1], pos[2]]
            cmds.xform(inf, ws=True, t=mirror_pos)

            _copy_driven_keys(inf_info["name"], inf, inf_info["driven"])
            created_infs.append(inf)

        try:
            cmds.editDisplayLayerMembers(layer, [half] + created_infs, nr=True)
        except Exception:
            pass

        created_halves.append(half)

    if created_halves:
        cmds.inViewMessage(amg=u"<hl>Half ミラー作成</hl>", pos="topCenter", fade=True)


def _collect_support_data(start, mirror_start):
    start_short = start.split("|")[-1]
    mirror_short = mirror_start.split("|")[-1] if mirror_start else None
    if start_short.endswith("_L") or start_short.endswith("_R"):
        base_name = start_short[:-2]
    else:
        base_name = start_short
    joints = cmds.ls(type="joint", l=True) or []
    supports = []
    for joint in joints:
        short = joint.split("|")[-1]
        if not (short.startswith(start_short) or short.startswith(base_name)):
            continue
        if "_Sup" not in short:
            continue
        if "_L" in start_short and "_L" not in short:
            continue
        if "_R" in start_short and "_R" not in short:
            continue
        if "_L" in start_short and "_R" in short:
            continue
        if "_R" in start_short and "_L" in short:
            continue
        parent = cmds.listRelatives(joint, p=True, f=True)
        radius = 1.0
        try:
            radius = cmds.getAttr(joint + ".radius")
        except Exception:
            radius = 1.0
        supports.append({
            "name": joint,
            "short": short,
            "position": cmds.xform(joint, q=True, ws=True, t=True),
            "radius": radius,
            "parent": parent[0] if parent else None,
            "driven": _list_driven_attributes(joint),
            "base_prefix": base_name,
            "mirror_prefix": mirror_short,
        })
    return supports or None


def _cleanup_support(support_infos):
    if not support_infos:
        return
    for info in support_infos:
        mirror_name = _support_mirror_name(info)
        if not mirror_name:
            continue
        existing = cmds.ls(mirror_name, l=True) or []
        for node in existing:
            try:
                cmds.delete(node)
            except Exception:
                pass


def _build_support_joints(data):
    if not data:
        return

    layer = _ensure_display_layer(SUPPORT_LAYER)
    created = []
    for info in data:
        mirror_name = _support_mirror_name(info)
        if not mirror_name:
            continue
        new_name = _uniquify(mirror_name)
        try:
            duplicated = cmds.duplicate(info["name"], po=True)[0]
        except Exception:
            continue
        try:
            duplicated = cmds.rename(duplicated, new_name)
        except Exception:
            duplicated = cmds.rename(duplicated, _uniquify(new_name))

        cmds.parent(duplicated, w=True)
        parent = info.get("parent")
        target_parent = None
        if parent:
            mirror_parent = _mirror_path(parent)
            if cmds.objExists(mirror_parent):
                target_parent = mirror_parent
            elif cmds.objExists(parent):
                target_parent = parent
        if target_parent:
            try:
                cmds.parent(duplicated, target_parent)
            except Exception:
                pass
        try:
            pos = info.get("position")
            if pos and len(pos) == 3:
                mirror_pos = [-pos[0], pos[1], pos[2]]
                cmds.xform(duplicated, ws=True, t=mirror_pos)
        except Exception:
            pass
        try:
            cmds.setAttr(duplicated + ".radius", max(0.01, info["radius"]))
        except Exception:
            pass

        _copy_driven_keys(info["name"], duplicated, info["driven"])

        try:
            cmds.editDisplayLayerMembers(layer, duplicated, nr=True)
        except Exception:
            pass
        created.append(duplicated)

    if created:
        cmds.inViewMessage(amg=u"<hl>Support ミラー作成</hl>", pos="topCenter", fade=True)


def _support_mirror_name(info):
    mirror_name = _mirror_name(info["short"])
    if mirror_name:
        return mirror_name
    base_prefix = info.get("base_prefix")
    mirror_prefix = info.get("mirror_prefix")
    if base_prefix and mirror_prefix and info["short"].startswith(base_prefix):
        return mirror_prefix + info["short"][len(base_prefix) :]
    return None


def mirror_twist_and_half():
    selection = cmds.ls(sl=True, type="joint") or []
    if not selection:
        cmds.warning(u"ジョイントを選択してください。")
        return

    cmds.undoInfo(openChunk=True)
    try:
        for joint in selection:
            mirror_joint = _mirror_name(joint)
            mirror_exists = mirror_joint and cmds.objExists(mirror_joint)

            if mirror_joint and not mirror_exists:
                cmds.warning(u"{0} のミラー先ジョイントが見つかりません。".format(joint))

            if mirror_exists:
                twist_data = _collect_twist_data(joint)
                if twist_data:
                    _build_twist_chain(twist_data, mirror_joint)

                half_data = _collect_half_data(joint)
                if half_data:
                    _build_half_chain(half_data, mirror_joint)
            elif not mirror_joint:
                cmds.warning(u"{0} には '_L' / '_R' の識別子がないため、Twist/Half のミラーをスキップします。".format(joint))

            support_data = _collect_support_data(joint, mirror_joint if mirror_exists else None)
            if support_data:
                _cleanup_support(support_data)
                _build_support_joints(support_data)
    finally:
        cmds.undoInfo(closeChunk=True)


if __name__ == "__main__":
    mirror_twist_and_half()
